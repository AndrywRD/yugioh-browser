#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import vm from "node:vm";

const ROOT = process.cwd();
const TABLE_PATH = path.join(ROOT, "fm_cards.txt");
const LOCAL_FUSIONS_PATH = path.join(ROOT, ".tmp_sources", "YGO-FM-Database", "data", "fusions.js");
const REMOTE_FUSIONS_URL = "https://raw.githubusercontent.com/falsepopsky/YGO-FM-Database/development/data/fusions.js";
const OUTPUT_TS_PATH = path.join(ROOT, "packages", "game", "src", "data", "fmFusions.generated.ts");
const OUTPUT_MD_PATH = path.join(ROOT, "FM_FUSOES_COMPLETAS.md");

function slugifyTitle(value) {
  return value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/&/g, " and ")
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_");
}

function parseTableLine(line) {
  const match = line.match(/^(\d{3})\s+(.+?)\s+-\s+([0-9 ]*)\/([0-9 ]*)\s+-\s+(\d{8})\s+(\d+)$/);
  if (!match) return null;

  const [, numberRaw, titleRaw, atkRaw, defRaw, passwordRaw, costRaw] = match;
  const atkText = atkRaw.trim();
  const defText = defRaw.trim();

  return {
    number: Number.parseInt(numberRaw, 10),
    numberPadded: numberRaw,
    title: titleRaw.trim(),
    atk: atkText ? Number.parseInt(atkText, 10) : 0,
    def: defText ? Number.parseInt(defText, 10) : 0,
    hasStats: atkText.length > 0 && defText.length > 0,
    password: passwordRaw,
    cost: Number.parseInt(costRaw, 10),
    templateId: `fm_${numberRaw}_${slugifyTitle(titleRaw.trim())}`
  };
}

async function loadFusionSource() {
  if (fs.existsSync(LOCAL_FUSIONS_PATH)) {
    return fs.readFileSync(LOCAL_FUSIONS_PATH, "utf8");
  }

  const response = await fetch(REMOTE_FUSIONS_URL);
  if (!response.ok) {
    throw new Error(`Unable to download fusion source (${response.status})`);
  }
  return response.text();
}

function parseFusionsList(sourceText) {
  const context = {};
  vm.createContext(context);
  vm.runInContext(sourceText, context, { timeout: 20_000 });
  if (!Array.isArray(context.fusionsList)) {
    throw new Error("fusionsList not found in source");
  }
  return context.fusionsList;
}

function toPairKey(numberA, numberB) {
  const left = Math.min(numberA, numberB);
  const right = Math.max(numberA, numberB);
  return `${left}:${right}`;
}

function buildFusionPairs(fusionsList) {
  const pairMap = new Map();
  const conflicts = [];
  let directedCount = 0;

  for (let card1 = 1; card1 < fusionsList.length; card1 += 1) {
    const entries = fusionsList[card1];
    if (!Array.isArray(entries)) continue;
    for (const entry of entries) {
      if (!entry || typeof entry.card !== "number" || typeof entry.result !== "number") continue;
      directedCount += 1;
      const card2 = entry.card;
      const result = entry.result;
      const key = toPairKey(card1, card2);
      const existing = pairMap.get(key);
      if (typeof existing === "number" && existing !== result) {
        conflicts.push({ key, existing, incoming: result });
        continue;
      }
      if (typeof existing !== "number") {
        pairMap.set(key, result);
      }
    }
  }

  const pairs = Array.from(pairMap.entries())
    .map(([key, resultNumber]) => {
      const [left, right] = key.split(":").map((part) => Number.parseInt(part, 10));
      return { leftNumber: left, rightNumber: right, resultNumber };
    })
    .sort((a, b) => {
      if (a.leftNumber !== b.leftNumber) return a.leftNumber - b.leftNumber;
      return a.rightNumber - b.rightNumber;
    });

  return { pairs, conflicts, directedCount };
}

function formatCardLabel(cardByNumber, number) {
  const card = cardByNumber.get(number);
  if (!card) return `#${String(number).padStart(3, "0")} (Unknown)`;
  return `#${card.numberPadded} ${card.title}`;
}

function buildTsSource(pairs, cardByNumber) {
  const lines = [];
  lines.push("// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.");
  lines.push("// Generated by scripts/generate-fm-fusions.mjs");
  lines.push("");
  lines.push("export interface FmFusionPair {");
  lines.push("  leftNumber: number;");
  lines.push("  rightNumber: number;");
  lines.push("  resultNumber: number;");
  lines.push("  leftTemplateId: string;");
  lines.push("  rightTemplateId: string;");
  lines.push("  resultTemplateId: string;");
  lines.push("}");
  lines.push("");
  lines.push("export const FM_FUSION_PAIRS: FmFusionPair[] = [");

  for (const pair of pairs) {
    const leftCard = cardByNumber.get(pair.leftNumber);
    const rightCard = cardByNumber.get(pair.rightNumber);
    const resultCard = cardByNumber.get(pair.resultNumber);

    if (!leftCard || !rightCard || !resultCard) continue;

    lines.push("  {");
    lines.push(`    leftNumber: ${pair.leftNumber},`);
    lines.push(`    rightNumber: ${pair.rightNumber},`);
    lines.push(`    resultNumber: ${pair.resultNumber},`);
    lines.push(`    leftTemplateId: ${JSON.stringify(leftCard.templateId)},`);
    lines.push(`    rightTemplateId: ${JSON.stringify(rightCard.templateId)},`);
    lines.push(`    resultTemplateId: ${JSON.stringify(resultCard.templateId)}`);
    lines.push("  },");
  }

  lines.push("];");
  lines.push("");
  return `${lines.join("\n")}\n`;
}

function buildMarkdown(pairs, cardByNumber) {
  const lines = [];
  lines.push("# Fusoes Completas do Yu-Gi-Oh! Forbidden Memories");
  lines.push("");
  lines.push(`- Total de combinacoes unicas (A+B): **${pairs.length}**`);
  lines.push("- Fonte: base de fusoes do YGO-FM-Database (fusions.js)");
  lines.push("- Formato: `Carta A + Carta B -> Resultado`");
  lines.push("");
  lines.push("## Lista Completa");
  lines.push("");

  for (const pair of pairs) {
    lines.push(`- ${formatCardLabel(cardByNumber, pair.leftNumber)} + ${formatCardLabel(cardByNumber, pair.rightNumber)} -> ${formatCardLabel(cardByNumber, pair.resultNumber)}`);
  }

  lines.push("");
  return `${lines.join("\n")}\n`;
}

async function main() {
  if (!fs.existsSync(TABLE_PATH)) {
    throw new Error(`Table file not found: ${TABLE_PATH}`);
  }

  const tableContent = fs.readFileSync(TABLE_PATH, "utf8");
  const rows = tableContent
    .split(/\r?\n/)
    .map((line) => parseTableLine(line))
    .filter(Boolean);

  const cardByNumber = new Map(rows.map((row) => [row.number, row]));

  const fusionSource = await loadFusionSource();
  const fusionsList = parseFusionsList(fusionSource);
  const { pairs, conflicts, directedCount } = buildFusionPairs(fusionsList);

  const tsSource = buildTsSource(pairs, cardByNumber);
  fs.mkdirSync(path.dirname(OUTPUT_TS_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_TS_PATH, tsSource, "utf8");

  const markdown = buildMarkdown(pairs, cardByNumber);
  fs.writeFileSync(OUTPUT_MD_PATH, markdown, "utf8");

  console.log(`Generated: ${path.relative(ROOT, OUTPUT_TS_PATH)}`);
  console.log(`Generated: ${path.relative(ROOT, OUTPUT_MD_PATH)}`);
  console.log(`Directed entries parsed: ${directedCount}`);
  console.log(`Unique pairs generated: ${pairs.length}`);
  console.log(`Conflicts detected: ${conflicts.length}`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});

