#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const TABLE_PATH = path.join(ROOT, "fm_cards.txt");
const IMAGES_DIR = path.join(ROOT, "apps", "web", "public", "images", "cartas");
const OUTPUT_TS_PATH = path.join(ROOT, "packages", "game", "src", "data", "fmCards.generated.ts");
const OUTPUT_REPORT_PATH = path.join(ROOT, "fm_cards_missing_images.txt");

const KNOWN_ALIASES = new Map([
  ["dragonessthewichedknight", "dragonessthewickedknight"],
  ["fiendreflection1", "fiendrefrection1"],
  ["fiendreflection2", "fiendrefrection2"],
  ["flamecerberus", "flamecerebrus"],
  ["revivalofsengenjin", "revivalofsennengenjin"],
  ["revivalofserpentnightdragon", "revivedofserpentnightdragon"],
  ["rhaintumdosoftheredsword", "rhaimundosoftheredsword"],
  ["serpentmaurauder", "serpentmarauder"],
  ["kagenigen", "kageningen"],
  ["psycopuppet", "psychopuppet"],
  ["hungeryburger", "hungryburger"],
  ["tremendosefire", "tremendousfire"],
  ["eradicadingaerosol", "eradicatingaerosol"],
  ["threeleggedzombie", "threeleggedzombies"],
  ["twolongrods1", "twinlongrods1"],
  ["darkmask", "maskofdarkness"],
  ["thewitchthatfeedsonlife", "thatwhichfeedsonlife"]
]);

function normalizeKey(value) {
  return value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/&/g, "and")
    .replace(/[^a-z0-9]/g, "");
}

function slugifyTitle(value) {
  return value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/&/g, " and ")
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_");
}

function parseTableLine(line) {
  const match = line.match(/^(\d{3})\s+(.+?)\s+-\s+([0-9 ]*)\/([0-9 ]*)\s+-\s+(\d{8})\s+(\d+)$/);
  if (!match) return null;

  const [, numberRaw, titleRaw, atkRaw, defRaw, passwordRaw, costRaw] = match;
  const atkText = atkRaw.trim();
  const defText = defRaw.trim();

  return {
    number: Number.parseInt(numberRaw, 10),
    numberPadded: numberRaw,
    title: titleRaw.trim(),
    atk: atkText ? Number.parseInt(atkText, 10) : 0,
    def: defText ? Number.parseInt(defText, 10) : 0,
    hasStats: atkText.length > 0 && defText.length > 0,
    password: passwordRaw,
    cost: Number.parseInt(costRaw, 10)
  };
}

function levenshtein(a, b) {
  if (a === b) return 0;
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;

  const previous = new Array(b.length + 1);
  const current = new Array(b.length + 1);

  for (let j = 0; j <= b.length; j += 1) previous[j] = j;

  for (let i = 1; i <= a.length; i += 1) {
    current[0] = i;
    for (let j = 1; j <= b.length; j += 1) {
      const substitutionCost = a[i - 1] === b[j - 1] ? 0 : 1;
      current[j] = Math.min(previous[j] + 1, current[j - 1] + 1, previous[j - 1] + substitutionCost);
    }
    for (let j = 0; j <= b.length; j += 1) previous[j] = current[j];
  }

  return previous[b.length];
}

function findBestFuzzyMatch(targetKey, imageKeys) {
  let bestKey = null;
  let bestDistance = Number.POSITIVE_INFINITY;

  for (const key of imageKeys) {
    if (Math.abs(key.length - targetKey.length) > 5) continue;
    if (key[0] !== targetKey[0]) continue;
    const distance = levenshtein(targetKey, key);
    if (distance < bestDistance) {
      bestDistance = distance;
      bestKey = key;
    }
  }

  if (!bestKey || bestDistance > 3) return null;
  return bestKey;
}

function pickFirstAvailable(keys, keyToFile, usedImageFiles) {
  for (const key of keys) {
    if (!key) continue;
    const fileName = keyToFile.get(key);
    if (!fileName) continue;
    if (usedImageFiles.has(fileName)) continue;
    return fileName;
  }
  return null;
}

function loadImages() {
  if (!fs.existsSync(IMAGES_DIR)) {
    throw new Error(`Image directory not found: ${IMAGES_DIR}`);
  }
  const files = fs
    .readdirSync(IMAGES_DIR, { withFileTypes: true })
    .filter((entry) => entry.isFile() && entry.name.toLowerCase().endsWith(".png"))
    .map((entry) => entry.name);

  const keyToFile = new Map();
  const numberToFile = new Map();
  const collisions = [];

  for (const fileName of files) {
    const baseName = fileName.replace(/\.png$/i, "").replace(/-fmr-en-vg$/i, "");
    if (/^\d+$/.test(baseName)) {
      numberToFile.set(Number.parseInt(baseName, 10), fileName);
    }
    const key = normalizeKey(baseName);
    if (keyToFile.has(key)) {
      collisions.push({ key, fileA: keyToFile.get(key), fileB: fileName });
      continue;
    }
    keyToFile.set(key, fileName);
  }

  return { files, keyToFile, numberToFile, collisions };
}

function buildGeneratedSource(cards, deckIds) {
  const lines = [];
  lines.push("// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.");
  lines.push("// Generated by scripts/generate-fm-catalog.mjs");
  lines.push("");
  lines.push("export interface FmCardEntry {");
  lines.push("  number: number;");
  lines.push("  templateId: string;");
  lines.push("  name: string;");
  lines.push("  atk: number;");
  lines.push("  def: number;");
  lines.push("  hasStats: boolean;");
  lines.push("  password: string;");
  lines.push("  cost: number;");
  lines.push("  imagePath?: string;");
  lines.push("}");
  lines.push("");
  lines.push("export const FM_CARDS: FmCardEntry[] = [");

  for (const card of cards) {
    lines.push("  {");
    lines.push(`    number: ${card.number},`);
    lines.push(`    templateId: ${JSON.stringify(card.templateId)},`);
    lines.push(`    name: ${JSON.stringify(card.title)},`);
    lines.push(`    atk: ${card.atk},`);
    lines.push(`    def: ${card.def},`);
    lines.push(`    hasStats: ${card.hasStats ? "true" : "false"},`);
    lines.push(`    password: ${JSON.stringify(card.password)},`);
    lines.push(`    cost: ${card.cost},`);
    if (card.imagePath) {
      lines.push(`    imagePath: ${JSON.stringify(card.imagePath)}`);
    }
    lines.push("  },");
  }

  lines.push("];");
  lines.push("");
  lines.push("export const FM_BASE_DECK_TEMPLATE_IDS: string[] = [");
  for (const templateId of deckIds) {
    lines.push(`  ${JSON.stringify(templateId)},`);
  }
  lines.push("];");
  lines.push("");
  return `${lines.join("\n")}\n`;
}

function main() {
  if (!fs.existsSync(TABLE_PATH)) {
    throw new Error(`Table file not found: ${TABLE_PATH}`);
  }

  const tableContent = fs.readFileSync(TABLE_PATH, "utf8");
  const tableRows = tableContent
    .split(/\r?\n/)
    .map((line) => parseTableLine(line))
    .filter(Boolean);

  const { keyToFile, numberToFile, collisions, files } = loadImages();
  const imageKeys = Array.from(keyToFile.keys());

  const catalogCards = [];
  const missingByTable = [];
  const usedImageFiles = new Set();

  for (const row of tableRows) {
    const normalizedTitle = normalizeKey(row.title);
    const aliasKey = KNOWN_ALIASES.get(normalizedTitle);
    let fileName = pickFirstAvailable([normalizedTitle, aliasKey], keyToFile, usedImageFiles);

    if (!fileName) {
      const prefixMatches = imageKeys.filter(
        (key) => (key.startsWith(normalizedTitle) || normalizedTitle.startsWith(key)) && !usedImageFiles.has(keyToFile.get(key))
      );
      if (prefixMatches.length === 1) {
        fileName = keyToFile.get(prefixMatches[0]);
      }
    }

    if (!fileName) {
      const fuzzyKey = findBestFuzzyMatch(normalizedTitle, imageKeys);
      if (fuzzyKey) {
        const candidate = keyToFile.get(fuzzyKey);
        if (candidate && !usedImageFiles.has(candidate)) fileName = candidate;
      }
    }

    if (!fileName) {
      const numericCandidate = numberToFile.get(row.number);
      if (numericCandidate && !usedImageFiles.has(numericCandidate)) {
        fileName = numericCandidate;
      }
    }

    if (fileName) {
      usedImageFiles.add(fileName);
    } else {
      missingByTable.push(row);
    }

    const templateId = `fm_${row.numberPadded}_${slugifyTitle(row.title)}`;
    catalogCards.push({
      ...row,
      templateId,
      imagePath: fileName ? `/images/cartas/${fileName}` : undefined
    });
  }

  const monsterCandidates = catalogCards.filter((card) => card.hasStats && (card.atk > 0 || card.def > 0));
  const deckIds = monsterCandidates.slice(0, 40).map((card) => card.templateId);

  const unusedImageFiles = files.filter((fileName) => !usedImageFiles.has(fileName));

  const generatedSource = buildGeneratedSource(catalogCards, deckIds);
  fs.mkdirSync(path.dirname(OUTPUT_TS_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_TS_PATH, generatedSource, "utf8");

  const reportLines = [];
  reportLines.push("FM CARD IMPORT REPORT");
  reportLines.push("=====================");
  reportLines.push(`Total cards in fm_cards.txt: ${tableRows.length}`);
  reportLines.push(`Total PNG images found: ${files.length}`);
  reportLines.push(`Cards with image: ${catalogCards.length - missingByTable.length}`);
  reportLines.push(`Cards without image: ${missingByTable.length}`);
  reportLines.push(`Total cards generated: ${catalogCards.length}`);
  reportLines.push(`Unused image files: ${unusedImageFiles.length}`);
  reportLines.push(`Deck templates generated: ${deckIds.length}`);
  reportLines.push("");

  if (collisions.length > 0) {
    reportLines.push("COLLISIONS (normalized keys)");
    reportLines.push("---------------------------");
    for (const collision of collisions) {
      reportLines.push(`${collision.key}: ${collision.fileA} | ${collision.fileB}`);
    }
    reportLines.push("");
  }

  reportLines.push("MISSING IMAGES (cards not imported)");
  reportLines.push("-----------------------------------");
  for (const card of missingByTable) {
    reportLines.push(`${card.numberPadded} - ${card.title}`);
  }
  reportLines.push("");

  reportLines.push("UNUSED IMAGE FILES");
  reportLines.push("------------------");
  for (const fileName of unusedImageFiles) {
    reportLines.push(fileName);
  }
  reportLines.push("");

  fs.writeFileSync(OUTPUT_REPORT_PATH, `${reportLines.join("\n")}\n`, "utf8");

  console.log(`Generated: ${path.relative(ROOT, OUTPUT_TS_PATH)}`);
  console.log(`Report: ${path.relative(ROOT, OUTPUT_REPORT_PATH)}`);
  console.log(`Generated ${catalogCards.length}/${tableRows.length} cards (${catalogCards.length - missingByTable.length} with image).`);
}

main();
