#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";
import vm from "node:vm";

const ROOT = process.cwd();
const INPUT_PATH = path.join(ROOT, ".tmp", "fmdb-data-chunk.js");
const OUTPUT_PATH = path.join(ROOT, "apps", "server", "src", "pve", "fmNpcSource.generated.ts");

const DROP_POOL_TYPES = ["SAPow", "SATec", "BCD"];
const TIER_UNLOCK_WINS = [0, 0, 1, 2, 4, 6, 8, 12];

function slugify(value) {
  return value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .toUpperCase()
    .replace(/[^A-Z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .replace(/_+/g, "_");
}

function extractVarArrayLiteral(source, name) {
  const marker = `var ${name}=[`;
  const start = source.indexOf(marker);
  if (start < 0) {
    throw new Error(`Unable to find variable ${name} in dataset.`);
  }

  const literalStart = start + (`var ${name}=`).length;
  let index = literalStart;
  let depth = 0;
  let inString = false;
  let quote = "";
  let escaped = false;

  for (; index < source.length; index += 1) {
    const ch = source[index];
    if (inString) {
      if (escaped) {
        escaped = false;
        continue;
      }
      if (ch === "\\") {
        escaped = true;
        continue;
      }
      if (ch === quote) {
        inString = false;
        quote = "";
      }
      continue;
    }

    if (ch === '"' || ch === "'") {
      inString = true;
      quote = ch;
      continue;
    }

    if (ch === "[") {
      depth += 1;
      continue;
    }

    if (ch === "]") {
      depth -= 1;
      if (depth === 0) {
        return source.slice(literalStart, index + 1);
      }
    }
  }

  throw new Error(`Could not parse array literal for ${name}.`);
}

function tierFromHandSize(handSize) {
  if (handSize <= 5) return 0;
  if (handSize <= 8) return 1;
  if (handSize <= 10) return 2;
  if (handSize <= 12) return 3;
  if (handSize <= 14) return 4;
  if (handSize <= 16) return 5;
  if (handSize <= 18) return 6;
  return 7;
}

function buildDeckCardNumbers(pools) {
  const deckEntries = pools.filter((entry) => entry.PoolType === "Deck");
  const fallbackEntries = pools.filter((entry) => DROP_POOL_TYPES.includes(entry.PoolType));
  const source = deckEntries.length > 0 ? deckEntries : fallbackEntries;

  const weightByCard = new Map();
  for (const entry of source) {
    const prev = weightByCard.get(entry.CardId) ?? 0;
    weightByCard.set(entry.CardId, prev + Number(entry.CardProbability ?? 0));
  }

  const sortedCards = Array.from(weightByCard.entries())
    .filter(([, weight]) => weight > 0)
    .sort((a, b) => (b[1] - a[1]) || (a[0] - b[0]));

  if (sortedCards.length === 0) return [];

  const totalWeight = sortedCards.reduce((acc, [, weight]) => acc + weight, 0);
  const deck = [];

  for (const [cardId, weight] of sortedCards) {
    if (deck.length >= 40) break;
    const targetCopies = Math.max(1, Math.round((weight / totalWeight) * 40));
    for (let i = 0; i < targetCopies && deck.length < 40; i += 1) {
      deck.push(cardId);
    }
  }

  let rr = 0;
  while (deck.length < 40 && rr < sortedCards.length * 40) {
    const [cardId] = sortedCards[rr % sortedCards.length];
    rr += 1;
    deck.push(cardId);
  }

  return deck;
}

function buildDropCards(pools) {
  const dropsByType = new Map();
  for (const poolType of DROP_POOL_TYPES) {
    dropsByType.set(poolType, pools.filter((entry) => entry.PoolType === poolType));
  }

  const chanceByCard = new Map();

  for (const [poolType, entries] of dropsByType.entries()) {
    const total = entries.reduce((acc, entry) => acc + Number(entry.CardProbability ?? 0), 0);
    if (total <= 0) continue;

    for (const entry of entries) {
      const chance = Number(entry.CardProbability ?? 0) / total;
      const prev = chanceByCard.get(entry.CardId) ?? 0;
      if (chance > prev) chanceByCard.set(entry.CardId, chance);
    }
  }

  return Array.from(chanceByCard.entries())
    .map(([cardNumber, chance]) => ({
      cardNumber,
      chance: Number(chance.toFixed(6))
    }))
    .sort((a, b) => (b.chance - a.chance) || (a.cardNumber - b.cardNumber));
}

function buildGeneratedSource(entries) {
  const lines = [];
  lines.push("// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.");
  lines.push("// Generated by scripts/generate-fm-npc-source.mjs");
  lines.push("");
  lines.push("export interface FmNpcSourceEntry {");
  lines.push("  id: string;");
  lines.push("  sourceDuelistId: number;");
  lines.push("  name: string;");
  lines.push("  handSize: number;");
  lines.push("  tier: number;");
  lines.push("  rewardGold: number;");
  lines.push("  unlockRequirement: { type: \"NONE\" } | { type: \"WINS_PVE\"; wins: number };");
  lines.push("  deckCardNumbers: number[];");
  lines.push("  rewardDropCards: Array<{ cardNumber: number; chance: number }>;");
  lines.push("}");
  lines.push("");
  lines.push("export const FM_NPC_SOURCE: FmNpcSourceEntry[] = [");

  for (const entry of entries) {
    lines.push("  {");
    lines.push(`    id: ${JSON.stringify(entry.id)},`);
    lines.push(`    sourceDuelistId: ${entry.sourceDuelistId},`);
    lines.push(`    name: ${JSON.stringify(entry.name)},`);
    lines.push(`    handSize: ${entry.handSize},`);
    lines.push(`    tier: ${entry.tier},`);
    lines.push(`    rewardGold: ${entry.rewardGold},`);
    if (entry.unlockRequirement.type === "NONE") {
      lines.push("    unlockRequirement: { type: \"NONE\" },");
    } else {
      lines.push(`    unlockRequirement: { type: \"WINS_PVE\", wins: ${entry.unlockRequirement.wins} },`);
    }

    lines.push("    deckCardNumbers: [");
    for (const cardNumber of entry.deckCardNumbers) {
      lines.push(`      ${cardNumber},`);
    }
    lines.push("    ],");

    lines.push("    rewardDropCards: [");
    for (const drop of entry.rewardDropCards) {
      lines.push(`      { cardNumber: ${drop.cardNumber}, chance: ${drop.chance} },`);
    }
    lines.push("    ]");
    lines.push("  },");
  }

  lines.push("];\n");
  return lines.join("\n");
}

function main() {
  if (!fs.existsSync(INPUT_PATH)) {
    throw new Error(`Input dataset not found: ${INPUT_PATH}`);
  }

  const source = fs.readFileSync(INPUT_PATH, "utf8");
  const duelistsLiteral = extractVarArrayLiteral(source, "Ds");
  const poolsLiteral = extractVarArrayLiteral(source, "lo");

  const duelists = vm.runInNewContext(`(${duelistsLiteral})`);
  const pools = vm.runInNewContext(`(${poolsLiteral})`);

  const poolsByDuelist = new Map();
  for (const pool of pools) {
    const duelistsPools = poolsByDuelist.get(pool.Duelist) ?? [];
    duelistsPools.push(pool);
    poolsByDuelist.set(pool.Duelist, duelistsPools);
  }

  const entries = duelists
    .map((duelist) => {
      const duelistPools = poolsByDuelist.get(duelist.DuelistId) ?? [];
      const tier = tierFromHandSize(duelist.HandSize ?? 5);
      const unlockWins = TIER_UNLOCK_WINS[Math.min(tier, TIER_UNLOCK_WINS.length - 1)] ?? 0;
      const rewardGold = 40 + tier * 25 + Math.max(0, (duelist.HandSize ?? 5) - 5) * 2;

      return {
        id: `FM_${String(duelist.DuelistId).padStart(2, "0")}_${slugify(duelist.Duelist)}`,
        sourceDuelistId: duelist.DuelistId,
        name: duelist.Duelist,
        handSize: duelist.HandSize ?? 5,
        tier,
        rewardGold,
        unlockRequirement: unlockWins <= 0 ? { type: "NONE" } : { type: "WINS_PVE", wins: unlockWins },
        deckCardNumbers: buildDeckCardNumbers(duelistPools),
        rewardDropCards: buildDropCards(duelistPools)
      };
    })
    .sort((a, b) => (a.tier - b.tier) || (a.sourceDuelistId - b.sourceDuelistId));

  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_PATH, buildGeneratedSource(entries), "utf8");

  console.log(`Generated ${entries.length} NPCs at ${OUTPUT_PATH}`);
}

main();
